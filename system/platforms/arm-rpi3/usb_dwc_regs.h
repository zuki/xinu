/**
 * @file usb_dwc_regs.h
 * @ingroup usbhcd
 *
 * DesignWare Hi-Speed USB 2.0 On-The-Go Controllerのレジスタ.
 *
 */
/* Embedded Xinu, Copyright (C) 2013.  All rights reserved. */

#ifndef _ARM_USB_DWC_REGS_H_
#define _ARM_USB_DWC_REGS_H_

#include <usb_util.h>

/**
 * @def DWC_NUM_CHANNELS
 * DWCホストのチャンネル数である. それぞれが独立のUSB転送に使用できる。
 * BCM2835 (Raspberry Pi)では8チャンネル使用できる。これはドキュメント
 * "BCM2835 ARM Peripherals" の201ページに記載されている。
 */
#define DWC_NUM_CHANNELS 8

/**
 * @ingroup usbhcd
 *
 * DesignWare Hi-Speed USB 2.0 On-The-Goコントローラのレジスタレイアウト.
 * これについての正式なドキュメントは存在しない。ただし、レジスタの位置
 * （とそのある程度の意味）はSynopsys社が提供したこのハードウェアの
 * Linuxドライバなど、他のコードで見つけることができる。
 *
 * ここではレジスタのすべてのビットを明示的に定義してはいない。なぜなら、
 * 大部分はドライバで使用されておらず、このファイルを複雑にするからである。
 * たとえば、サスペンド、ハイバネーション、OTGプロトコル、ホストモードでは
 * なくデバイスモードで動作するコアに特有の機能については記載していない。
 *
 * ドライバで使用しているビットやフィールドについては、それらが何をする
 * ものであるかを理解した上で、完全に文書化するように努めた。しかし、
 * 公式の文書にアクセスできないので、すべての情報が正しいことを保証する
 * ものではない。
 */
struct dwc_regs {

    /** [0x000] : GOTGCTL: OTGコントロール/ステータスレジスタ. */
    uint32_t otg_control;

    /** [0x004] : GOTGINT: OTG割り込みレジスタ. */
    uint32_t otg_interrupt;

    /**
     * [0x008] : GAHBCFG: AHBコンフィグレーションレジスタ.
     *
     * このレジスタはDWCとシステムの他のペリフェラルとのインタフェースを
     * 構成する  */
    uint32_t ahb_configuration;

/**
 * @def DWC_AHB_INTERRUPT_ENABLE
 * USBコントローラからの割り込みを有効にする（実際はアプリケーション全体の
 * 割り込みを有効にする: アンマスク）. デフォルトは無効（マスク）になっている。 */
#define DWC_AHB_INTERRUPT_ENABLE  (1 << 0)

/**
 * AHBコンフィグレーションレジスタのビット [4:1] はBroadcomによりBCM2835ように
 * 再定義されている。したがって、こののフラグはBCM2835でのみ妥当である。
 *
 * このビットは次のように定義されている。
 *
 *    1 = 未処理のAXI書き込みがすべて完了するのを待ってからDMAの完了を
 *        （内部で）シグナリングする。
 *    0 = 待たない
 *
 * Linuxドライバがそうしているのでこのビットをセットしたが、動作に違いは
 * 見られなかった。
 */
#define BCM_DWC_AHB_AXI_WAIT      (1 << 4)

/**
 * AHBコンフィグレーションレジスタのこのビットに1を書き込むとUSBコントローラ
 * （実際はコア）がDMAモードで実行するようになる。デフォルトは無効 (0)
 */
#define DWC_AHB_DMA_ENABLE        (1 << 5)

    /** [0x00c] : GUSBCFG: USBコンフィグレーションレジスタ. */
    uint32_t core_usb_configuration;


    /**
     * [0x010] : GRSTCTL: コアリセットレジスタ.
     *
     * ソフトウェアはこのレジスタを使ってコア内部の様々なハードウェアを
     * リセットすることができる。
     */
    uint32_t core_reset;

    /**
     * AHB Master Idle: AHBマスタステートマシンがIDLE条件にあることを示す
     */
#define DWC_AHB_MASTER_IDLE (1 << 31)

    /**
     * コアリセットレジスタのこのビットに1を書き込むとソフトウェアリセットが
     * 開始される。このビットはリセットが完了すると自動的にクリアされる。
     */
#define DWC_SOFT_RESET      (1 << 0)

    /**
     * [0x014] : GINTSTS: DWCコア割り込みレジスタ.
     *
     * このレジスタは保留されているトップレベルのDWC割り込みの状態を含んでいる。
     * 1は割り込みが保留されていることを、0は保留されていないことを意味する。
     *
     * 少なくともport_intr[b24]とhost_channel_intr[b25]については、このレジスタに書き込む
     * のではなく、他のどこかで割り込みをクリアしなければならないことに注意。
     */
    union dwc_core_interrupts {
        /** レジスタ値 */
        uint32_t val;
        struct {
            /** [2-0] : TODO */
            uint32_t stuff             : 3;

            /**
             * [3] : SOF, micro-SOF, Keep-Aliveが転送された.
             */
            uint32_t sof_intr          : 1;
            /** [4-23] : TODO */
            uint32_t morestuff         : 20;

            /**
             * [24] : ホストポートの状態が変更された。ソフトウェアはHPRTでホスト
             * ポートの現在の状態を調べて、変更のあったステータスのフラグを
             * クリアする必要がある。
             */
            uint32_t port_intr         : 1;     /* Bit 24 */

            /**
             * [25] : ホストチャネル割り込みが発生した。ソフトウェアはHAINTで
             * どのチャネルで割り込みが保留されているか調べ、その割り込みを
             * 処理して、そのチャネルの割り込みをクリアする必要がある。
             */
            uint32_t host_channel_intr : 1;     /* Bit 25 */
            /** [31-26] : TODO */
            uint32_t evenmorestuff     : 6;
        };
    } core_interrupts;

    /**
     * [0x018] : GINTMSK: コア割り込みマスクレジスタ.
     *
     * このレジスタはGINTSTSと同じ形式であり、対応する割り込みを有効 (1) または
     * 無効 (0) にする。リセット後の初期状態はすべて 0
     */
    union dwc_core_interrupts core_interrupt_mask;

    /** [0x01c] : GRXSTSR: 受信ステータスキュー読み込み */
    uint32_t receive_status;

    /** [0x020] : GRXSTSP: 受信ステータスキュー読み込みとポップアウト */
    uint32_t receive_status_pop;

    /**
     * [0x024] : GRXFSIZ: 受信FIFOサイズレジスタ.
     *
     * 受信FIFOのサイズ（4バイトワード単位）を保持する.
     *
     * コントローラを使用する前にソフトウェアはこのレジスタをセット
     * する必要がある。動的FIFOの構成についてはhwcfg3レジスタの中を参照。
     */
    uint32_t rx_fifo_size;

    /**
     * [0x028] : GNPTXFSIZ: 非周期転送FIFOサイズレジスタ.
     *
     * 下位16ビットには非周期転送FIFOの動的FIFOのためにコントローラにより
     * 確保されたメモリの開始地点からの（4バイトワード単位の）オフセットを
     * 保持する。上位16ビットには（4バイトワード単位の）サイズを保持する。
     *
     * コントローラを使用する前にソフトウェアはこのレジスタをセット
     * する必要がある。動的FIFOの構成についてはhwcfg3レジスタの中を参照。
     */
    uint32_t nonperiodic_tx_fifo_size;

    /** [0x02c] : GNPTXSTS: 非周期転送FIFO/Queueステータスレジスタ */
    uint32_t nonperiodic_tx_fifo_status;

    /** [0x030] : GI2CCTL: I2Cアクセスレジスタ */
    uint32_t i2c_control;

    /** [0x034] : GPVNDCTL: PHYベンダー制御レジスタ */
    uint32_t phy_vendor_control;

    /** [0x038] : GGPIO: GPIOレジスタ */
    uint32_t gpio;

    /** [0x03c] : GUID: ユーザIDレジスタ */
    uint32_t user_id;

    /** [0x040] : GSNPSID: Synopsys IDレジスタ */
    uint32_t vendor_id;

    /** [0x044] : GHWCFG1: ユーザハードウェア構成1レジスタ */
    uint32_t hwcfg1;

    /** [0x048] : GHWCFG2: ユーザハードウェア構成2レジスタ */
    uint32_t hwcfg2;

    /**
     * [0x04c] : GHWCFG3: ユーザハードウェア構成3レジスタ.
     *
     * 上位16ビット（RO）には動的FIFO（受信、周期送信、非周期送信）の（ワード単位の）
     * 最大合計サイズを保持する。ソフトウェはrx_fifo_size, nonperiodic_tx_fifo_size,
     * host_perodic_tx_fifo_sizeで3つの動的FIFOを設定する必要がある。このとき、
     * これらの合計サイズはこのレジスタの合計サイズを超えてはならない。また、FIFOは
     * 重なってはならない。
     *
     * 注: コントローラがDMAモードで動作していても、サフとウェアは動的FIFOを
     * 明示的に構成しなければならない。なぜなら、FIFOサイズとオフセットのデフォルト値は
     * 不正な値だからである。たとえば、BCM2835のおけるこのコントローラのBroadcomに
     * よるインスタンスでは動的FIFOとして4080バイトしか利用できない。しかし、動的
     * FIFOのサイズはそれぞれ4096, 32, 0と設定されておりこれは合計すると4080を超える
     * ので不正である。<b>これをしないと知らないうちにメモリ破壊することになる。</b>
     *
     * 下位16ビットにはここでは説明していない様々なフラグを保持している。
     * 我々のドライバはこのフラグは使用しない。
     */
    uint32_t hwcfg3;

    /** [0x050] : GHWCFG4: ユーザハードウェア構成4レジスタ */
    uint32_t hwcfg4;

    /** [0x054] : GLPMCFG: コアLPM構成レジスタ */
    uint32_t core_lpm_configuration;

    /** [0x058] : GPWRDN: 電源切断レジスタ */
    uint32_t global_powerDn;

    /** [0x05c] : GDFIFOCFG: DFIFOソフトウェア構成レジスタ */
    uint32_t global_fifo_config;

    /** [0x060] : GADPCTL: ADPタイマー、制御・ステータスレジスタ */
    uint32_t adp_control;

    /** [0x064-0x0Fc] : 予約済み*/
    uint32_t reserved_0x64[39];

    /**
     * [0x100] : HPTXFSIZ: ホスト周期転送FIFOサイズレジスタ.
     *
     * 下位16ビットには周期転送FIFOの動的FIFOのためにコントローラにより
     * 確保されたメモリの開始地点からの（4バイトワード単位の）オフセットを
     * 保持する。上位16ビットには（4バイトワード単位の）サイズを保持する。
     *
     * コントローラを使用する前にソフトウェアはこのレジスタをセット
     * する必要がある。動的FIFOの構成についてはhwcfg3レジスタの中を参照。
     */
    uint32_t host_periodic_tx_fifo_size;

    /** [0x104-0x13c] : デバイス用レジスタ, [0x140-3FF] : 予約済み */
    uint32_t stuff[191];

    /** @ingroup usbhcd
     * @name ホストレジスタ
     *
     * このポイント(0x400)から始まるレジスタは「ホスト」レジスタである.
     * これらはOTG（On-The-Go）プロトコルの「ホスト」パートで使用される。
     * OTGはこのハードウェアがUSBホストまたはUSBデバイスとして動作することを
     * 可能にする。このドライバではホストだけを扱うのでデバイスに対する
     * レジスタは宣言しない
     */

    /** [0x400] : HCFG: ホスト構成レジスタ */
    uint32_t host_configuration;

    /** [0x404] : HFIR: ホストフレーム間隔レジスタ */
    uint32_t host_frame_interval;

    /** [0x408] : HFNUM: ホストフレーム番号/フレーム残り時間レジスタ.
     *
     * - [31-16] : 現在のフレームの残り時間
     * - [15-0]  : フレーム番号
     */
    uint32_t host_frame_number;

    /** [0x40c] : 予約済み */
    uint32_t host_reserved_0x40c;

    /** [0x410] : HPTXSTS: ホスト周期転送FIFO/Queueステータスレジスタ */
    uint32_t host_fifo_status;

    /**
     * [0x414] : HAINT: ホスト全チェネル割り込みレジスタ.
     *
     * 各ホストチェネルで割り込みがあったか否かを示すビット（1チャネル1ビット）を
     * 保持する。このレジスタに書き込んでも割り込みをクリアすることはできない。
     * クリアには各チャネルのHCINTレジスタを使用すること。
     */
    uint32_t host_channels_interrupt;

    /**
     * [0x418] : HAINTMASK: ホスト全チャネル割り込みマスクレジスタ.
     *
     * HAINTと同じフォーマットだが、このレジスタの1は対応するホストチャネルの
     * 割り込みを有効にすることを意味する。ソフトウェアはこのレジスタを変更する
     * ことができる。リセット後のデフォルト値はすべて0である。
     */
    uint32_t host_channels_interrupt_mask;

    /** [0x41c] : HFLBAddr: ホストフレームリスト基底アドレスレジスタ */
    uint32_t host_frame_list;

    /** [0x420-0x43F] : 予約済み */
    uint32_t host_reserved_0x420[8];

    /**
     * [0x440] : HPRT: ホストポート制御・ステータスレジスタ.
     *
     * ルートハブに論理的に接続されたポートである「ホストポート」に
     * 関するステータスクエリに応答するために必要な情報を提供する。
     *
     * このレジスタを変更する場合、ソフトウェアはその値を読んだ後、
     * enabled, connected_changed, enabled_changed, overcurrent_changedの
     * クリアして、変更を避ける必要がある。これらのビットは1を書き込むと
     * クリアされるからである。
     */
    union dwc_host_port_ctrlstatus {
        /** レジスタ値 */
        uint32_t val;
        struct {
            /** [0] : デバイス接続の有無.
             *
             *  - 1: デバイスがこのポートに接続されている.
             *  - 0: このポートにはデバイスが接続されていない.
             *
             *  変更ができるのはハードウェアのみ。
             */
            uint32_t connected : 1; /* Bit 0 */

            /**
             * [1] : connectedビットに変更があった場合にハードウェアがセットする.
             * ソフトウェアは1を書き込むことで了解してクリアできる。ハードウェアに
             * よるこのビットのセットによりcore_interrupt_maskレジスタのport_intrを
             * 設定することにより有効になる割り込みが生成される。
             */
            uint32_t connected_changed : 1; /* Bit 1 */

            /**
             * [2] : ポートが有効か.
             *
             * - 1: ポートは有効.
             * - 0: ポートは無効.
             *
             * 注1: リセット後、ホストポートはデフォルトで有効になる.
             * 注2: 1を書き込むとそのポートは無効になるようだ.
             */
            uint32_t enabled : 1; /* Bit 2 */

            /**
             * [3] : enabledビットに変更があった場合にハードウェアがセットする.
             * ソフトウェアは1を書き込むことで了解してクリアできる。ハードウェアに
             * よるこのビットのセットによりcore_interrupt_maskレジスタのport_intrを
             * 設定することにより有効になる割り込みが生成される。
             */
            uint32_t enabled_changed : 1; /* Bit 3 */

            /**
             * [4] : 過電流があるか.
             *
             * - 1: このポートで過電流条件が発生
             * - 0: このポートで過電流条件はない
             *
             * 変更ができるのはハードウェアのみ。
             */
            uint32_t overcurrent : 1; /* Bit 4 */

            /**
             * [5] : overcurrentビットに変更があった場合にハードウェアがセットする.
             * ソフトウェアは1を書き込むことで了解してクリアできる。ハードウェアに
             * よるこのビットのセットによりcore_interrupt_maskレジスタのport_intrを
             * 設定することにより有効になる割り込みが生成される。
             */
            uint32_t overcurrent_changed : 1; /* Bit 5 */

            /**
             * [6] : レジュームシグナルを設定するためにソフトウェアがセットする.
             */
            uint32_t resume : 1; /* Bit 6 */

            /**
             * [7] : ポートをサスペンドするためにソフトウェアがセットする.
             */
            uint32_t suspended : 1; /* Bit 7 */

            /**
             * [8] : ポートのリセットを開始するためにソフトウェアがセットできる.
             * リセットが完了させるためにソフトウェアは60ミリ秒後にこのビットを
             * クリアする必要がある。
             */
            uint32_t reset : 1; /* Bit 8 */
            /** [9] : 予約済み */
            uint32_t reserved : 1; /* Bit 9 */

            /**
             * [11-10] : データラインの現在のロジック (10: logic of D+; 11: logic of D-).
             *
             * 変更ができるのはハードウェアのみ。
             */
            uint32_t line_status : 2; /* Bits 10-11*/

            /**
             * [12] : 電源が入っているか.
             *
             * - 1: ポートの電源オン.
             * - 0: ポートの電源オフ.
             *
             * ソフトウェアはこのビットを変更することでポートの電源をオン (1) /
             * オフ (0)することができる。
             */
            uint32_t powered : 1; /* Bit 12 */
            /** [16-13] : テスト制御用 */
            uint32_t test_control : 4; /* Bits 13-16 */

            /**
             * [18-17] : 接続されたデバイスの速度（もしあれば）.
             * connectedビットが設定されている場合にのみ意味があると考えるべき。S
             *
             * 00: HS (high speed); 01: FS (full speed); 10: LS (low speed)
             *
             * 変更ができるのはハードウェアのみ。
             */
            uint32_t speed : 2; /* Bits 17-18 */
            /** [31-19] : 予約済み */
            uint32_t reserved2 : 13; /* Bits 19-32 */

        };
    } host_port_ctrlstatus; /**< [0x440] : HPRT: ホストポート制御・ステータスレジスタ */

    /** [0x444-0x4fc] : 予約済み */
    uint32_t host_reserved_0x444[47];

    /**
     * [0x500][16] : ホストチャネルレジスタ配列.
     * - 0x00 : HCCHARn: Host Channel-n Characteristics Register
     * - 0x04 : HCSPLTn: Host Channel-n Split Control Register
     * - 0x08 : HCINTn: Host Channel-n Interrupt Register
     * - 0x0c : HINTMSKn: Host Channel-n Interrupt Mask Register
     * - 0x10 : HCTSIZn: Host Channel-n Transfer Size Register
     * - 0x14 : HCDMAn: Host Channel-n DMA Address Register
     * - 0x18 : 予約済み
     * - 0x1c : HCDMABn: Host Channel-n DMA Buffer Address Register
     *
     * 各ホストチャネルは、独立したUSB転送またはUSBトランザクションを
     * 同時に実行するために使用することができる。 USB転送は複数の
     * トランザクション、またはパケットで構成されることがある。チャネルの
     * 再プログラムを避けるために、他の転送をそのチャネルにスケジュールする
     * 前に転送のすべてのトランザクションに1つのチャネルを使用することが
     * 有用であろう。
     */
    struct dwc_host_channel {
        /**
         * [0x500] HCCHAR: ホストチャネル属性レジスタ.
         *
         * このチャネルを特定のUSBデバイスの特定のエンドポイントとの間の
         * 転送に使用するために準備する必要がある様々なフィールドが含まれている。
         *
         * このレジスタは、チャンネルが別の転送のために再プログラムされるか、
         * 転送が別のチャンネルに移動されない限り、それが何個のパケットで構成
         * されていても、転送を行うときに1回だけプログラムされる必要がある。
         */
        union dwc_host_channel_characteristics {
            /** レジスタ値 */
            uint32_t val;
            struct {
                /**
                 * [10-0] : エンドポイントが送受信できる最大パケットサイズ.
                 * 転送を開始する前にプログラムする必要がある。
                 */
                uint32_t max_packet_size     : 11; /* Bits 0-10  */

                /**
                 * [14-10] : エンドポイント番号（bEndpointAddressの下位4ビット）.
                 * 転送を開始する前にプログラムする必要がある。
                 */
                uint32_t endpoint_number     : 4;  /* Bits 11-14 */

                /**
                 * [15] : エンドポイントの方向（bEndpointAddressの上位ビット）.
                 * 転送を開始する前にプログラムする必要がある。
                 */
                uint32_t endpoint_direction  : 1;  /* Bit  15    */
                /** [16] : 予約済み */
                uint32_t reserved            : 1;  /* Bit  16    */

                /**
                 * [17] : デバイスの速度.
                 *
                 * - 1: 通信するデバイスがLSで接続された時
                 * - 0: それ以外
                 *
                 * 転送を開始する前にプログラムする必要がある。
                 */
                uint32_t low_speed           : 1;  /* Bit  17    */

                /**
                 * [19-18] : エンドポイントのタイプ（bmAttributesの下位2ビット）.
                 * 転送を開始する前にプログラムする必要がある。
                 */
                uint32_t endpoint_type       : 2;  /* Bits 18-19 */

                /**
                 * [21-20] : マイクロフレーム当たりに実行できる最大トランザックション数.
                 * 通常は1だが、HSのインターラプト転送とアイソクロナス転送では
                 * 1 + (wMaxPacketSizeのビット11, 12）をセットするべきである。
                 * 転送を開始する前にプログラムする必要がある。
                 */
                uint32_t packets_per_frame   : 2;  /* Bits 20-21 */

                /**
                 * [28-22] : エンドポイントが位置するデバイスのUSBデバイスアドレス.
                 * 転送を開始する前にプログラムする必要がある。
                 */
                uint32_t device_address      : 7;  /* Bits 22-28 */

                /**
                 * [29] : （すべてのトランザクション用に）チャネルを有効にする直前に
                 * host_frame_numberレジスタの下位ビットの値と逆の値をセットする必要が
                 * ある。そういないと一部のトランザクションでフレームオーバランエラーが
                 * 発生する。
                 * TODO: 具体的にどの様になっているのか。
                 */
                uint32_t odd_frame           : 1;  /* Bit  29    */

                /**
                 * [30] : 1をセットするとチャネルを停止することができる.
                 * トランザクションが完了したり、エラーが発生するとトランザクションは
                 * 自動的に停止するので通常操作の間は必要がない。
                 */
                uint32_t channel_disable     : 1;  /* Bit  30    */

                /**
                 * [31] : 1をセットするとチャネルが有効になり、実際にUSB上で
                 * トランザクションが開始する. このビットはcharacteristics、
                 * split_control、transferレジスタとおそらくはその他のレジスタ
                 * （転送による）をプログラムした後にセットする必要がある。
                 */
                uint32_t channel_enable      : 1;  /* Bit  31    */
            }; /**< ビット説明 */
        } characteristics; /**< [0x500] HCCHAR: ホストチャネル属性レジスタ */

        /**
         * [0x504] : HCSPLT: ホストチャネル分割制御レジスタ -
         *
         * HSハブに接続されたLS, FSのデバイスと通信するための分割トランザクションを
         * 設定するために使用する. これを行うにはsplit_enable に1を、その他の
         * フィールドに以下の説明の値を設定する。これを行わない場合は、転送を
         * 開始する前にこのレジスタをクリアする必要がある。
         *
         * チャネル属性レジスタ同様、このレジスタもチャネルを複数回有効にして1つの
         * 転送のすべてのパケットを送信する場合に1回だけプログラムする必要がある。
         */
        union dwc_host_channel_split_control {
            /** レジスタ値 */
            uint32_t val;
            struct {
                /**
                 * [6-0] : LS, FSデバイスが接続されるHSハブ上のポートの0始まりのインデック.
                 */
                uint32_t port_address          : 7;  /* Bits 0-6   */

                /**
                 * [13-7] : このLS, FSデバイスのとランザックション変換器として動作する
                 * HSハブのUSBデバイスアドレス. これは必ずしもデバイスが物理的に接続
                 * されたハブとは限らない。接続されたハブがFSハブまたはLSハブかも
                 * しれないからである。ソフトウェアはUSBデバイスツリーを（ルートハブの
                 * 方向に向かって）たどってHSハブを見つけて、そのアドレスを設定する必要が
                 * ある。
                 */
                uint32_t hub_address           : 7;  /* Bits 7-13  */

                /**
                 * [15-14] : 各OUTトランザクションでどのペイロードを送信するかを決める.
                 *
                 * - 0b11: すべてのペイロード
                 * - 0b10: 最初のペイロード
                 * - 0b01: 中間のペイロード
                 * - 0b00: 最後のペイロード
                 */
                uint32_t transaction_position  : 2;  /* Bits 14-15 */

                /**
                 * [16] : 分割トランザクションの完了か.
                 *
                 * - 0: Start Splitトランザクションを行う
                 * - 1: Complete Splitトランザクションを行う
                 *
                 * 分割トランザクションが有効な場合、チャネルを有効にする前に
                 * プログラムする必要がある。分割開始トランザクションで開始し、
                 * 転送が完了するまで各トランザクションでこのビットを交互に
                 * 使用する必要があることに注意されたい。
                 */
                uint32_t complete_split        : 1;  /* Bit  16    */
                /** [30-17] : 予約済み */
                uint32_t reserved              : 14; /* Bits 17-30 */

                /**
                 * [31] : 1をセットすると分割トランザクションが有効になる.
                 */
                uint32_t split_enable          : 1;  /* Bit  31    */
            };
        } split_control; /**< [0x504] : HCSPLT: ホストチャネル分割制御レジスタ */

        /**
         * [0x508] : HCINT: ホストチャネル割り込みレジスタ -
         *
         * このチャネルで起きたステータス条件のビットマスク。
         *
         * これらのビットは「実際の」割り込みの有無にかかわらず使用することが
         * できる。これらのビットが設定されたときにCPUが実際に割り込みを受ける
         * ようにするには、interrupt_maskの該当するビットを設定し、さらに
         * チャネルからの割り込みをhost_channels_interrupt_maskレジスタで、
         * チャネル全体の割り込みをcore_interrupt_maskレジスタで、DWCハードウェア
         * 全体の割り込みをahb_configurationレジスタとシステム固有の割り込み
         * コントローラで有効にすることが必要である。
         */
        union dwc_host_channel_interrupts {
            /** レジスタ値 */
            uint32_t val;
            struct {
                /**
                 * [0] : リクエストされたUSB転送が成功裏に完了した.
                 *
                 * 例外と注意事項:
                 *
                 * - 分割トランザクションを行っている場合、全体の転送が実際には
                 *   完了していなくても、このビットはComplete Splitトランザクションが
                 *   終了した後に設定される。
                 *
                 * - 転送は、データがチャネルにプログラムされた範囲までしか完了
                 *   しない。たとえば、コントロール転送には3つのフェーズがあり、
                 *   それらを個別にチャネルにプログラムする必要がある。このフラグは
                 *   各フェーズが正常に完了するごとに設定される。
                 *
                 * - OUT転送は、要求されたバイト数のデータが正確に転送されたときに
                 *   完了したとみなされるが、IN転送は、要求されたバイト数のデータが
                 *   正確に転送されたとき、または予想より短いパケットを受信したときに
                 *   完了したとみなされる。
                 */
                uint32_t transfer_completed       : 1;  /* Bit 0     */

                /**
                 * [1] : チャネルが停止された. このビットがセットされるとチャネルは
                 * アイドル状態になり、ソフトウェアがアクションをするまで何もおこらない。
                 *
                 * チャネルはいくつかの理由で停止する場合がある。我々の経験では
                 * ソフトウェアがアクションを起こす必要があるすべての可能な状況を
                 * カバーしているので、実際に有効にする必要があるのはこのチャネル
                 * 割り込みだけある。少なくともDMAモードでは、コントローラはある程度
                 * 自律的に動作して転送を完了し、ソフトウェアがアクションを起こす
                 * 必要がある場合にのみ、この割り込みを発行する。
                 *
                 * チャネルが停止する状況には、以下のようなものがある。
                 *
                 * - 転送が完了し、上で説明したtransfer_completedフラグが設定された
                 *
                 * - Start Split、または、Complete Splitトランザクションが終了した
                 *
                 * - Complete Splitトランザクションを実行しようとしたときにハブが
                 *   NYETパケットを送信して、Splitトランザクションがまだ完了していない
                 *   ことを伝えた
                 *
                 * - INインターラプト転送を実行しようとしたときに、デバイスがNAKパケットを
                 *   送信し、その時点で送信するデータがないことを通知した
                 *
                 * - AHBエラー、データトグルエラー、トランザクションエラー、ストール状態、
                 *   フレームオーバーランエラーなど、複数のエラーのいずれかが発生した。
                 */
                uint32_t channel_halted           : 1;  /* Bit 1     */

                /**
                 * [2] : AHB (ARM Advanced High-Performance Bus) でエラーが発生した
                 */
                uint32_t ahb_error                : 1;  /* Bit 2     */

                /**
                 * [3] : デバイスがSTALLハンドシェークパケットを発行した.
                 * （エンドポイントは停止される、または、コントロールパイプが
                 * サポートされなくなる）
                 */
                uint32_t stall_response_received  : 1;  /* Bit 3     */

                /**
                 * [4] : デバイスがNACKハンドシェークパケットを発行した.
                 * （受信デバイスはデータを受け付けることができない、
                 * 送信デバイスはデータを送信できない）
                 *
                 * インターラプトエンドポイントからIN転送を実行中に送信するべき
                 * データがないとチャネルはこのビットをセットして停止する。
                 * チャネルを再起動するためにはソフトウェアの介入が必要であるため、
                 * これは実際のトランザクションが割り込み駆動であったとしても、
                 * ソフトウェアはインターラプトエンドポイント（ハブやHIDデバイスなど）の
                 * ポーリングを行う必要があることをこれは意味する。
                 */
                uint32_t nak_response_received    : 1;  /* Bit 4     */

                /**
                 * [5] : デバイスがACKハンドシェークパケットを発行した.
                 * （受信デバイスはエラーのないパケットを確認した）
                 */
                uint32_t ack_response_received    : 1;  /* Bit 5     */

                /**
                 * [6] : デバイスがNYETハンドシェークパケットを発行した.
                 */
                uint32_t nyet_response_received   : 1;  /* Bit 6     */

                /**
                 * [7] : 経験によると、通常、これはソフトウェアによるチャネルの
                 * プログラムに誤りがあることを示している。
                 */
                uint32_t transaction_error        : 1;  /* Bit 7     */

                /**
                 * [8] : 予期せぬバスアクティビティが発生した。.
                 */
                uint32_t babble_error             : 1;  /* Bit 8     */

                /**
                 * [9] : TODO フレームオーバランが発生した?.
                 */
                uint32_t frame_overrun            : 1;  /* Bit 9     */

                /**
                 * [10] : エンドポイントに一連のDATAトランザクションを
                 * 発行している際に、転送レジスタのpacket_idメンバに
                 * DATA0, DATA1のいずれかの正しいパケットIDを指定しなかった.
                 */
                uint32_t data_toggle_error        : 1;  /* Bit 10    */
                /** [11] : バッファが利用できない. */
                uint32_t buffer_not_available     : 1;  /* Bit 11    */
                /** [12] : 過剰トランザクションエラーが発生した. */
                uint32_t excess_transaction_error : 1;  /* Bit 12    */
                /** [13] : チャネルのディスクリプタリストがロールオーバーした. */
                uint32_t frame_list_rollover      : 1;  /* Bit 13    */
                /** [31-14] : 予約済み */
                uint32_t reserved                 : 18; /* Bits 14-31 */
            };
        } interrupts; /**< [0x508] : HCINT: ホストチャネル割り込みレジスタ */

        /**
         * [0x50c] : HCINTMSK: ホストチャネル割り込みマスクレジスタ -
         *
         * ホストチャネル割り込みレジスタと同じフォーマットであるが、
         * 対応する割り込みを有効にする (1)、または無効にする (0) のに
         * ソフトウェアが使用する。
         */
        union dwc_host_channel_interrupts interrupt_mask;

        /**
         * [0x510] : HCTSIZ: ホストチャネル転送サイズレジスタ -
         *
         * 転送に関するその他の情報を格納するのに使用する。転送を開始する前に
         * プログラムする必要がある。
         */
        union dwc_host_channel_transfer {
            /** レジスタ値 */
            uint32_t val;
            struct {
                /**
                 * [18-0] : 送信または受信するデータのサイズ（バイト単位）.
                 * 転送を開始する前にプログラムする必要がある。最大パケット長より
                 * 大きくてもかまわない。
                 *
                 * IN転送の場合、ハードウェアはパケットを受信するごとに受信したバイト
                 * 数だけこのフィールドをデクリメントする。 スプリットトランザクションの
                 * 場合、デクリメントはスタートスプリットではなく、コンプリートスプリットの
                 * 後に行われる。ソフトウェアは、転送中にエラーが発生した場合やフルサイズ
                 * またはショートサイズのいずれかで完了した場合を含む任意の時点で受信した
                 * バイト数を決定するために、もともとの転送サイズからこのフィールドの値を
                 * 減算することができる。
                 *
                 * OUT転送の場合、ハードウェアはこのフィールドを期待通りには更新しない。
                 * データが転送された際に少なくともすべての場合で、ハードウェアが
                 * デクリメントすることはない。したがって、ソフトウェアはこのフィールドの
                 * 値を頼りにこれまでに何バイトのデータが送信されたかを示すことはできない。
                 * ソフトウェアはpacket_countフィールドを検査し、packet_countが0の場合は
                 * すべてのデータが送信されたと、packet_countが0以外の場合は
                 * 送信されたデータ量がエンドポイントの最大パケットサイズに[元のパケット
                 * カウントからpacket_countを引いた値]をかけたものに等しいと仮定しなければ
                 * ならない。
                 */
                uint32_t size         : 19; /* Bits 0-18  */

                /**
                 * [28-19] : 送信残りのパケット数、または受信残りのパケット最大数.
                 * 転送を開始する前にプログラムする必要がある。パケット数はサイズを
                 * 最大パケットサイズで割り、パケット単位に切り上げたものとして
                 * 計算する。特別なケースとして、転送サイズが0バイトの場合、パケット
                 * 数は1と設定しなければならない。
                 *
                 * ハードウェアはパケットの送受信が成功した場合にこのレジスタを
                 * デクリメントする。分割トランザクションの場合は、Start Splitでは
                 * なく、Complete Splitの後にデクリメントされる。IN転送の最終受信
                 * パケットがshortの場合もカウントされる。
                 */
                uint32_t packet_count : 10; /* Bits 19-28 */

                /**
                 * [30-29] : USBプロトコルで使用されるPacket IDの上位2ビット.
                 *
                 * コントロール転送のSETUPフェーズを実行する場合、必要なSETUP
                 * トークンが生成するために0x3を設定する。
                 *
                 * コントール転送のDATAフェーズを実行する場合、必要なDATA1
                 * パケットIDでDATAパケットを開始するために初めは0x2を設定する。
                 *
                 * コントロール転送のSTATUSフェーズを実行する場合、必要なDATA1
                 * パケットIDを生成するために0x2を設定する。
                 *
                 * バルク転送、アイソクロナス転送、インターラプト転送を開始する
                 * 場合は、必要なDATA0パケットIDを生成するために0x0を設定する。
                 *
                 * 複数のDATAパケットで構成される転送の場合、ハードウェアが次の
                 * パケットに使用するパケットIDでこのフィールドを更新する。
                 * したがって、このフィールドを再プログラムする必要があるのは、
                 * 転送を別のチャネルに移動したり、転送が完了する前にそのチャネルを
                 * 再使用する場合だけである。その際、ソフトウェアはこのフィールドを
                 * 保存し、正しく再プログラムできるようにする必要がある。
                 */
                uint32_t packet_id    : 2;  /* Bits 29-30 */

                /**
                 * [31] : TODO
                 */
                uint32_t do_ping      : 1;  /* Bit  31    */
            };
        } transfer; /**< [0x510] : HCTSIZ: ホストチャネル転送サイズレジスタ */

        /**
         * [0x514] : HCDMA: ホストチャネルDMAアドレスレジスタ.
         *
         * DMAを使用してハードウェアがデータを読み書きするためのワードアラインド
         * アドレス。 送信または受信するデータのサイズが0でない限り、転送を開始
         * する前にプログラムする必要がある。ハードウェアは正常に受信または送信
         * されたバイト数だけこのアドレスをインクリメントする。これはtransfer.sizeの
         * デクリメントに対応する。
         *
         * 注: このレジスタを使用する前に、AHB Configuration RegisterでDMAを有効に
         * する必要がある。そうしないとハードウェアはスレーブモードであるとみなされ、
         * 別の方法で制御する必要があるが、これは私たちのドライバでは使用していないので
         * 説明しない。
         *
         * BCM2835固有の注意: 理論的には、このレジスタに書き込むアドレスはARM物理
         * アドレスではなく、バスアドレスでなければならない。 しかし、経験によれば
         * 単にARM物理アドレスを使用しても動作は同じである。
         */
        uint32_t dma_address;
        /** [0x518] : 予約済み */
        uint32_t reserved_1;
        /** [0x51c] : HCDMAB: ホストチャネルDMAバッファアドレスレジスタ */
        uint32_t reserved_2;
    } host_channels[DWC_NUM_CHANNELS]; /**< ホストチャネルレジスタ配列 */
    /** [0x6f0-0x7fc] : 予約済み */
    uint32_t host_reserved_after_channels[(0x800 - 0x500 -
                        (DWC_NUM_CHANNELS * sizeof(struct dwc_host_channel))) /
                         sizeof(uint32_t)];



    /** [0x800-0xdfc] : デバイス用レジスタ */
    uint32_t reserved_0x800[(0xe00 - 0x800) / sizeof(uint32_t)];

    /** [0xe00] : PCGCCTL: 電源・クロックゲーティング制御レジスタ */
    uint32_t power;
};

/** レジスタが正しく宣言されていることを確認する. これはダミーコードであり
 * コンパイルされるとなくなる。  */
static inline void _dwc_check_regs(void)
{
    STATIC_ASSERT(offsetof(struct dwc_regs, vendor_id) == 0x40);
    STATIC_ASSERT(offsetof(struct dwc_regs, host_periodic_tx_fifo_size) == 0x100);
    STATIC_ASSERT(offsetof(struct dwc_regs, host_configuration) == 0x400);
    STATIC_ASSERT(offsetof(struct dwc_regs, host_port_ctrlstatus) == 0x440);
    STATIC_ASSERT(offsetof(struct dwc_regs, reserved_0x800) == 0x800);
    STATIC_ASSERT(offsetof(struct dwc_regs, power) == 0xe00);
}

#endif /* _USB_DWC_REGS_H_ */
