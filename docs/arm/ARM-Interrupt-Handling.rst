割り込み処理 (ARM)
========================

このページではEmbedded Xinuが `ARMアーキテクチャ <http://en.wikipedia.org/wiki/ARM_architecture>`__ 上でどのように割り込み処理を行うかを説明します。
このページではARM固有の詳細についてだけ説明しています。特に、割り込みが
規定する実際の意味は :doc:`rpi/Raspberry-Pi` の :doc:`rpi/BCM2835-Interrupt-Controller` の
ようにボード固有のメカニズムにより決定されることを理解する必要があります。
なお、ARMアーキテクチャとその例外/割込み処理機構については、各種
バージョンの  `ARMアーキテクチャリファレンスマニュアル <http://infocenter.arm.com/help/index.jsp>`__
など、ARM社から十分なドキュメントが提供されています。このページは
Embedded Xinuのコンテキストのける関連する詳細の概要を提供することだけを
目的としています。

.. contents::
   :local:

IRQとFIQ
-------------

概要
~~~~~~~~

ARMプロセッサは2種類の「割り込み」を定義しています:

-  **IRQ** (Interrupt Request: 割り込みリクエスト)。*ノーマルな* 割り込み
   です。
-  **FIQ** (Fast Interrupt Request: 高速割り込みリクエスト)。これはソフト
   ウェアが特定のソースからの割り込みの速度や優先順位を上げるために使用
   できるオプションの機能です。Embedded Xinuでは簡単のためにFIQを使用
   **しません** 。しかし、Embedded Xinuカーネルの上に、または代わりに、
   リアルタイムソフトウェアや組み込みソフトウェアを設計しようとしている
   人にとってはFIQは便利かもしれません。

IRQもFIQもARMがサポートする **例外** の一例です。"IRQ"という用語は
一般的によく使われますが、ここでは特にARMアーキテクチャのIRQ例外を指す
ことに注意してください。

IRQ/FIQの受信
~~~~~~~~~~~~~~~~~~~~~~~

ARMがIRQを受信すると特別な **IRQモード** になり、デフォルトでは物理
メモリアドレス ``0x18`` で実行を開始します。同様に、ARMがFIQを受信すると
特別な **FIQモード** になり、デフォルトでは物理メモリアドレス ``0x1C``
から実行を開始します。IRQまたはFIQを有効にする前に、ソフトウェアには
ARM命令を適切なアドレスにコピーすることが期待されます。IRQの場合、
ARM命令を1つ入れる余地しかないので、ハンドラ全体が格納されている場所への
分岐命令である必要があります。Embedded Xinuでは、この特別な「グルー」
命令、すなわち、 **例外ベクタ** は :source:`loader/platforms/arm-rpi/start.S`
で設定されています。IRQハンドラの「全体」は :source:`system/arch/arm/irq_handler.S`
にあります。

バンク化レジスタ
~~~~~~~~~~~~~~~~~~~

IRQモードとFIQモードではいくつかのレジスタは **バンク化** されています。
つまり、その内容は現在のプロセッサモードに依存します。このようなレジスタの
利点は、割り込み処理コードが元の値を明示的に保存する必要がないことです。
FIQモードはIRQモードよりも多くのレジスタがバンク化されていますが、IRQ
モードでもFIQモードでもスタックポインタ (sp) はバンク化されています。
これは基本的には各モードが各自のスタックを使用できることを意味します。
ただし、簡単化のためと他のCPUアーキテクチャとの整合性を保つために、
Embedded Xinuではこの機能を使用して **いません** 。代わりに割り込み処理
コードはプロセッサを直ちにIRQモードから「システム」モードに切り替えます。
システムモードはEmbedded XinuがARM CPUを動作させる通常のモードです。
これは割り込み処理コードは現在実行中のスレッドのスタックを使用することを
意味します。おそらくこの方法の第一の欠点は各スレッドが必要とするスタック
サイズが増加することです。

割り込みの管理
-------------------

ARMは ``cpsr`` (Current Program Status Register)のビット7とビット6が
それぞれ0の場合にのみIRQとFIQに応答します。 （リセット後の）デフォルトでは
これらのビットはともに1なので、IRQとFIQを有効にするにはソフトウェアで
これらを0に初期設定する必要があります。同様に、IRQとFIQを無効にする必要が
ある場合は、これらを1に設定することができます。ただし、ソフトウェアは
必ずしもこれらのビットを明示的に操作する必要はありません。なぜなら、
これらのビットを変更し、プロセッサのモードを変更することができる
``cps`` (Change Program State) という代替命令が用意されているからです。

以下では、Embedded Xinuが割り込みを管理するために使用する
``enable()``, ``disable()``, ``restore()`` の各関数を説明します。
これらはすべてARMアセンブリ言語のファイル :source:`system/arch/arm/intutils.S`
で実装されています。

``enable()``
~~~~~~~~~~~~

``enable()`` はプロセッサがIRQ例外を受信できるようにします。

.. code-block:: none

    enable:
            cpsie i
            mov pc, lr

``enable()`` は ``cpsie`` ("Change Program State Interrupt Enable")
命令を実行してIRQを有効にします（Embedded XinuではFIQは使用しない
ことを思い出してください）。 そして、プログラムカウンタ (``pc``) を
リンクレジスタ (``lr``) の値で上書きして関数から復帰しています。
2番目の命令は関数呼び出しのオーバーヘッドに過ぎないので ``enable()``
の代わりにインラインアセンブリを含むインライン関数として効率的に実装
することができることに注意してください。

``disable()``
~~~~~~~~~~~~~

``disable()`` はIRQ例外をブロックし、 ``restore()`` に渡して以前の
状態に戻すことができる値を返します。以前の状態はIRQ無効かIRQ有効の
いずれかです。ただし、割り込みが ``disable()`` されているコード領域で
受け取ったIRQ例外は失われず、IRQが再び有効になるまで保留され続ける
ことに注意してください。

.. code-block:: none

    disable:
            mrs r0, cpsr
            cpsid i
            mov pc, lr

``disable()`` は ``cpsr`` (Current Program Status Register) を ``r0``
にコピーしますが、これはARMの呼び出し規約  [#calling]_ により、関数の
返り値です。したがって、 ``cpsr`` は ``restore()`` に渡して以前の
割り込み状態に戻すことができる値として扱われます。その後、``cpsid``
(Change Program State Interrupt Disable) 命令を実行し、実際にIRQ例外を
無効にします。

``restore()``
~~~~~~~~~~~~~

``restore()`` はIRQ例外の無効/有効状態を前回 ``disable()`` をを呼び出した
前の状態に復元します。

.. code-block:: none

    restore:
            msr cpsr_c, r0
            mov pc, lr

ARMの呼び出し規約 [#calling]_ により ``restore()`` への引数（以前の状態
の値。通常、コードでは ``im`` (interrupt mask) という変数に格納されます）
は ``r0`` で渡されます。そして、 ``r0`` は ``cpsr`` (Current Program Status
Register)
にコピーされます。これは ``disable()`` とは逆の処理になります。次に
``restore()`` はリンクレジスタの値でプログラムカウンタを上書きして
関数から復帰します。2番目の命令は関数呼び出しのオーバーヘッドに過ぎない
ので ``restore()`` の代わりにインラインアセンブリを含むインライン関数と
して効率的に実装することができることに注意してください。

参考文献
---------------

冒頭で述べたようにこのページではARMアーキテクチャの詳細しか扱って
しません。そのため、一般的に、IRQの例外に実際に意味を割り当てる
ために何らかの割り込みコントローラの使用を必要とする任意のプラット
フォームにおける割り込み処理についての完全な説明は行っていません。

- :doc:`rpi/Raspberry-Pi` の割り込みコントローラは :doc:`rpi/BCM2835-Interrupt-Controller` です。

注記
-----

.. [#calling] http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf
