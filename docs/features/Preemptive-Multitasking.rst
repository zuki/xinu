プリエンプティブマルチタスク
=============================

すべての現代的なOSと同様、XINUは **プリエンプティブマルチタスク** を
サポートしており、同じプロセッサ上で複数のスレッドが同時に実行されて
いるように見せかけることができます。プリエンプティブマルチタスクの
サポートは、マルチスレッドのサポートとプリエンプション機構の組み
合わせで構成されています。

.. _multiple_threads:
.. _thread_context:

マルチスレッド
----------------

XINUはマルチスレッドをサポートしていますが、一度に実行できるのは
1つのスレッドのみです。 **スレッドコンテキスト* とはスレッドの
保存された状態のことであり、主にCPUレジスタを指します。XINUプラット
フォームは新しいスレッドの作成とスレッドコンテキストを使用した
スレッドを切り替えを可能にする次の2つの関数を実装する必要があります。

-  ``setupStack()`` は、新しいスレッドのスタックを設定して、初期
   スレッドコンテキストとプロシージャの引数を含めるようにする役割を
   担っています。通常、このルーチンはCで実装されます。この関数は
   :source:`system/create.c` にある ``create()`` により内部的に
   呼び出されます。:source:`system/arch/arm/setupStack.c` を参照
   してください。
-  ``ctxsw()`` は、スレッドの切り替えを担当します。より具体的には、
   このルーチンは現在のスレッドのスレッドコンテキストを保存し、
   新しいスレッドのスレッドコンテキストを復元する必要があります。
   このルーチンは常にアセンブリ言語で実装されます。例として、
   :source:`system/arch/arm/ctxsw.S` を参照してください。

CPUアーキテクチャが異なると使用するレジスタと呼び出し規約が異なるので、
スレッドコンテキストのサイズとフォーマットはCPUアーキテクチャにより
異なります。スレッドコンテキストは ``setupStack()`` と ``ctxsw()`` で
作成されるので、少なくとも ``ctxsw()`` が新しいスレッドの開始、または
既存のスレッドの再開ができる範囲において、これら2つのルーチンは
互換性のあるコンテキストを作成しなければならないことに注意してください。

これについては、他の記事で特定のアーキテクチャについてより詳細に
説明されています。

- :doc:`/arm/ARM-Preemptive-Multitasking`

.. _preemption:

プリエンプション
--------------------

プリエンプションは、タイマー割り込みが発生し、XINUが現在実行中の
スレッドを再スケジュールしようとすると発生します。その結果、上で
説明した ``ctxsw()`` が呼び出され、異なるスレッドコンテキストに
切り替わる可能性があります（ *可能性がある* と言ったのは、同じ
スレッドが自分自身に再スケジュールされるときに ``ctxsw()`` が
呼ばれるようにコードが書かれているからです。その場合、 ``ctxsw()``
は保存したコンテキストを直ちに復元するので、これは一種のno-opです）。
タイマー割り込みの生成方法はプラットフォーム依存であり、同じCPU
アーキテクチャを共有するプラットフォームであっても異なる場合が
あります。例として、ARMベースのプラットフォームである
:doc:`/arm/rpi/Raspberry-Pi` に採用されている
:doc:`/arm/rpi/BCM2835-System-Timer` を参照してください。
