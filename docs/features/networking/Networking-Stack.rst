ネットワークスタックの設計
============================

新しいネットワークスタックの設計にはNETデバイスがありません。デバイスの
Read/Write関数のパラダイムはネットワークスタックにはうまく対応しません。
TCP、UDP、RAWソケットはネットワークデバイスから読み取るのではなく、
ネットワーク受信スレッドが一連の受信関数を呼び出して、ネットワーク
スタックの各レイヤでパケットを処理するからです。Write関数もパケットの
送信にはうまく機能しません。パケットの最終的な宛先がIPまたはARPレイアに
ならないと分からないからです。デバイスのWrite関数は、write関数を呼び出す
スレッドはデータを書き込むべきデバイスを正しく知っていると仮定します。
netif構造体のテーブル（デバイスのテーブルであるdevtabとは異なる）も
依然として保持され、ネットワークスタックがパケットを送受信するデバイス
（ETHなど）の構成とアカウンティング情報を格納します。

ネットワークインターフェースは :source:`netUp() <network/net/netUp.c>`
関数を使用してセットアップされます。 ``netUp()`` を呼び出す際には
基礎となるデバイス、IPアドレス、サブネットマスク、ゲートウェイを
提供する必要があります。

.. note::
    ``netUp()`` は :doc:`DHCP <DHCP>` を内蔵していません。代わりに、
    DHCPを構成するために  ``netUp()`` を呼び出す前に :source:`dhcpClient()
    <network/dhcpc/dhcpClient.c>` を呼び出す必要があります。DHCP
    クライアントはIPv4情報を取得するためにネットワークスタックを使用
    せずにデバイス（ETHなど）と直接対話します。

ネットワーク受信スレッドはデバイスからの受信パケットを継続的に読み込み
ます。各ネットワークインタフェースでは1つ以上のネットワーク受信スレッドが
実行されています。 ``netRecv()`` 関数にはデバイスからパケットを読み込み、
パケットの種類に応じて ``ipv4Recv()`` または ``arpRecv()`` を呼び出す
無限ループがあります。パケットはnetRecv関数内でローカル変数として宣言
されているバッファに読み込まれます。IP層では ``ipv4Recv()`` は
``tcpRecv()``, ``udpRecv()``, ``rawRecv()`` を呼び出すか、ルーティング
スレッドにパケットを渡します。ネットワーク受信スレッドの下ではパケットの
送信は決して行ってはいけません。着信パケットにより応答パケットを送信する
必要があるようなプロトコルでは、そのプロトコルは送信用の別スレッドを
持つ必要があります。たとえば、着信したTCPパケットに確認応答が必要な
データが含まれている場合、 ``tcpRecv()`` はフラグをセットするか確認
応答を送信するTCPモニタースレッドにメッセージを送信しなければなりません。

発信パケットを格納するためのグローバルバッファプールが割り当てられて
います。すべてのネットワークインタフェースが使用する1つのプールが
存在します。パケットを送信する場合、送信関数（ ``tcpSend()`` など）は
プールからバッファを取得し、適切な低レベル送信関数（ ``ipv4Send()`` など）
を呼び出します。そして、低レベル関数から戻った後にバッファをプールに返します。

ネットワークスタックはXinuバックエンドをルーターまたはマルチホームホスト
のいずれでも扱えるように設計されています。あるバックエンドのネットワーク
インタフェースで受信したパケットはそのバックエンドに向けたものである
場合もあれば、他のネットワーク宛先にルーティングする必要がある場合も
あります。ネットワーク層（IP層）は着信パケットをどのように処理
するかを決定します。 ``ipv4Recv()`` 関数では、IPパケットの宛先をすべての
アクティブなネットワークインターフェイスのIPアドレスとブロードキャスト
アドレスと比較します。IPパケットの宛先アドレスがそのパケットを受信した
インタフェースのIPアドレスまたは他のネットワークインタフェースのIP
アドレスと一致した場合、そのパケットは適切なトランスポート層の
受信関数（ ``udpRecv()`` や ``tcpRecv()`` など）に渡されます。宛先が
アクティブなネットワークインタフェースのどれとも一致しなかったIP
パケットは、ネットワークスタックのルーティングモジュールに渡されます。
すなわち、 ``rtRecv()`` 関数が呼び出されます。 ``rtRecv()`` では
パケットはグローバルバッファプールからのバッファにコピーされ、
ルーティングスレッドが処理するためのキューに入れられます。現在のところ、
ネットワークスタックはルータが過負荷になった場合に選択的破棄
アルゴリズムは使用されません。ルーティングするためのパケットのキューが
一杯になるとルーティングを必要とする後続のパケットはすべて破棄されます。
ルーティングスレッドはルーティングキューにある各パケットを処理します。
ルートがわからないパケットは破棄されます。そうでなければ、TTLが減じられ、
チェックサムが再計算され、 ``netSend()`` 関数が呼び出されます。
トランスポート層から送信されるパケット（``udpSend()`` や ``tcpSend()``
など）はルーティングスレッドには渡されません。トランスポート層は
ルートテーブル検索を実行する ``ipv4Send()`` を呼び出し、IPパケット
ヘッダーをセットし、``netSend()`` を呼び出します。

.. image:: XINUNetStack-Screen.jpeg
   :width: 600px
