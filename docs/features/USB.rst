USB
===

**USB (Universal Serial Bus)** はコンピュータシステムにデバイスを接続
するための規格です。キーボード、マウス、フラッシュドライブ、マイク、
ネットワークアダプタなど、さまざまなデバイスをサポートしています。

USBは現代のコンピュータシステム、さらには一部の「組み込み」デバイスに
至るまで、どこにでもあるものですが、USBのソフトウェアサポートの実装は
非常に難しいものです。これは、USBが非常に複雑であることが主な原因ですが、
これはいくつかの要因、たとえば、事実上あらゆる任意のデバイスのサポート、
デバイスの動的な着脱のサポート、複数のバージョンのUSB仕様との後方互換性、
サポートされる複数の速度と転送タイプなどにより発生します。USB 2.0仕様は
650ページにも及びますが、特定のUSBデバイスを制御するUSBソフトウェア
スタックとドライバをゼロから実装するために必要な情報のほんの一部しか
カバーしていません。

USBは非常に複雑なため、ここではUSBを完全に説明することはできませんし、
Embedded XinuのUSBの実装も完全に説明することはできません。ここでは
Embedded Xinuの実装の文脈におけるUSBの概要を説明します。USBの完全な
詳細については必然的にUSB仕様そのものやその他の関連する仕様やウェブ
ページを読む必要があります。Embedded Xinuの実装に関する詳細については、
ソースコードを読む必要があります。

.. contents::
   :local:

一般的なUSBに関する情報
-----------------------

バストポロジ
~~~~~~~~~~~~

基本的に、USBはコンピュータシステムにデバイスを接続するための手段でしか
ありません。USBバスはデバイスをツリー状に配置することでこれを実現します。
ツリーの各ノードが **USBデバイス** です。USBデバイスには **ハブ** と
**ファンクション** という2つの基本タイプがあります。USBハブはツリーの中に
「子」デバイスを持つことができますが、ファンクションは持つことができません。
ハブは他のハブの「子」になることができ、最大で7階層まで可能です。

ツリーのルートノードは **ルートハブ** です。すべてのUSBバスに1つずつあります
（ただし、後で述べるように、ホストコントローラドライバによって偽装されることが
あります）。

USBハブは **ポート** と呼ばれるデバイスを追加する取り付けポイントを一定数
提供します。USBポートは、完全に内蔵されている場合と、USBケーブルを差し込む
場所として「外部」に露出している場合があります。ユーザから見るとこの2つの
USBポートの姿には明確な違いがありますが、ソフトウェアから見ると違いはありません。
同様に、素朴なユーザーが「USBデバイス」と呼ぶような1つの物理的パッケージが
実際には（上で定義した）1つ以上のUSBデバイスが取り付けられる統合USBハブを
含んでいることもありえます。このような物理的パッケージは **複合デバイス** と
呼ばれます。マウスを取り付けるためのUSBポートが用意されているApple社のUSB
キーボードは複合デバイスの一例です。

USBは動的なバスであるため、USBデバイスは任意のタイミングでUSBから着脱する
ことができます。ハブを切り離すと、すべての子デバイスが切り離されることに
なります。

Embedded XinuのUSB実装は、USBバスの動的ツリートポロジーを完全にサポート
しています。


デバイス
~~~~~~~~~

USBの汎用性により、ハブでないUSBデバイスは、事実上何でもありです。これは
高度にネスト化されたデザインによって実現されています。

- USBデバイスは1つ以上の **コンフィギュレーション** を持ちます。
- コンフィギュレーションは1つ以上の **インタフフェース** を持ちます。
- インターフェースは1つ以上の **代替設定** を持ちます。
- 代替設定は1つ以上の **エンドポイント** を持ちます。

すべてのデバイス、コンフィギュレーション、インタフェース、エンドポイントは
対応する **ディスクリプタ** を持ち、USBソフトウェアはこれを読み取ることで
記述されたエンティティに関する情報を標準フォーマットで取得することができます。

このフォーマットは非常に複雑なデバイスを可能にしますが、ほとんどのデバイスは
比較的単純であり、1つのコンフィギュレーションしか持ちません。さらに、一般的な
デバイスは1つのインタフェースしか持っていません。実際、これを書いている時点に
おいて、Embedded XinunoのUSBサブシステムは一般的なケースしかサポートしていません。
そのため、デバイスは常に最初にリストアップされたコンフィグレーションで設定し、
個々のインタフェースに個別の「インタフェースドライバ」が必要かどうかを調べる
ことはせず、デバイス全体にデバイスドライバをバインドすることを試みます。

ホストコントローラ
~~~~~~~~~~~~~~~~~~~~

USBはポーリングバスであるため、USB上のすべての転送は **ホスト** によって
開始されます。ここでいう「ホスト」とは、USBソフトウェアと、実際にUSB上で
データを送受信し、ルートハブを維持するハードウェアであるUSBホストコントローラの
ことです。実はこれがUSBの厄介な部分の1つです。USBの仕様自体はソフトウェアと
ハードウェアの正確な役割分担を標準化していないため、仕様に「ホスト」と書かれて
いても誰が責任を負うのかよくわからないことが多いのです。

知っておくべき重要なことは、USBソフトウェアがハードウェアと直接出会う場所は
USBホストコントローラを操作する「USBホストコントローラドライバ」であるという
ことです。USBホストコントローラの中にはソフトウェアに対して標準的なインタフェース
（UHCI、OHCI、EHCIなど、いずれもUSB仕様とは別の仕様で定義されている）を提示する
ものがあります。また、標準的なインタフェースは提供されていませんがベンダーが提供する
ドキュメントやベンダーが提供するドライバを持つものもあります。 :doc:`/arm/rpi/Raspberry-Pi` で
使用されている :doc:`/arm/rpi/Synopsys-USB-Controller` はその一例です。もちろん、
ホストコントローラドライバを独自に実装する場合は、標準的なインタフェースのほうが
遥かに望ましいものです。

転送
~~~~~~~~~

USBデバイスと通信するために、ホストはUSB転送を使用してUSB上でデータを送受信します。
USB転送は特定のデバイスの特定のエンドポイントとの間で行われます。すべてのエンド
ポイントは特定のタイプのUSB転送に関連付けられ、以下のいずれかになります：

- **コントロール** 転送。これは通常、デバイスのコンフィグレーションに使用されます。
  この転送には主に2つのユニークな特徴があります。第一に、コントロール転送の実際の
  データの前に SETUP と呼ばれる特別なパケットが常にUSB上で送信され、ソフトウェアは
  このパケットの内容を指定する必要があります。第二に、すべてのデバイスには双方向の
  コントロール転送が可能なエンドポイントが1つあり、このエンドポイントはエンドポイント
  ディスクリプタに明示的に記載されることはありません。
- **インターラプト** 転送。（キーボードやマウスからのデータなど）少量のデータを時間
  制限付きで転送する場合に使用されます。
- **バルク** 転送。特定の時間を保証しない大量のデータの信頼性の高い（エラー検出を伴う）
  転送に使用されます（大容量記憶装置のデータの読み書きなど）。
- **アイソクロナス** 転送。エラー検出のない定期的なデータ転送に使用します（ビデオキャプチャなど）。

現在、Embedded Xinuはコントール転送、インターラプト転送、バルク転送を
サポートしています。アイソクロナス転送はまだテストされていません。また、
インターラプト転送は機能しますが、USBの仕様で要求されている時間的制約の
ある転送を保証するためにもう少し作業が必要かもしれません。

速度
~~~~~~

USBは複数の転送速度に対応しています。

- 1.5Mbit/s (低速: LS) (USB 1+)
- 12Mbit/s (フルスピード: FS) (USB 1+)
- 480Mbit/s (高速: HS) (USB 2.0+)
- 5000Mbit/s (超高速: SS) (USB 3.0+)

そうです、FSは2番目に遅い速度です。でも、何にでも12Mbit/sで十分だと思います。
しかし、レガシーデバイスとの後方互換性を維持する必要があるため、残念ながら、USBソフトウェア
（主にホストコントローラドライバ）は転送速度を考慮する必要がある。少なくとも、
LSまたはFSで接続されたデバイスとの転送は、HSで動作するUSBバスの部分を大幅に減速させる
ことなくLSまたはFSの転送を実行できるようにする一連の **分割トランザクション** と
して実行されることを認識する必要があります。

これを書いている時点では、Embedded XinuのUSBサブシステムはUSB 2.0を
サポートしており、LS、FS、HSで動作するデバイスをサポートしています。
USB 3.0のSSはサポートされていません。

.. _usb_subsystem:

Embedded XinuのUSBサブシステム
---------------------------------

USBに関する一般的な情報を示したので、USBソフトウェアスタックの
基本設計を理解することは容易でしょう。以下の説明は、確かにコードを
編成する唯一の方法ではありませんが、ほとんどのオペレーティング
システムで使用されている方法であり、USBが設計思想に基づいたもっとも理に
かなったものです。Embedded Xinuの観点からおそらく第一の疑問は、なぜUSB
デバイスとUSBコントローラはデフォルトでは他のEmbedded Xinuデバイスのように
``devtab`` にデバイスとして表示されないのかです。その理由は、USBは動的な
バスなので静的なテーブルでは記述できないこと、USBデバイスが高度なネスト
構造をとること、複数の転送タイプがサポートされていることにより、
単純な「デバイスからの ":source:`read() <system/read.c>`, :source:`write() <system/write.c>`"」パラダイムには複雑すぎるからです。

.. note::
    必要であれば、特定のUSBデバイスドライバを ``devtab``  にデバイス
    エントリに提供することはできます。ただし、物理デバイスは依然として
    ホットプラグ可能であることを考慮しなければなりません。

.. note::

    すべてのEmbedded Xinu :ref:`platforms <supported_platforms>` が
    USBをサポートしているわけではありません。USBハードウェアが利用
    できないか、適切なUSBホストコントローラドライバが実装されていない
    ためです。

.. _usb_components:

構成要素
~~~~~~~~~~

-  **USBホストコントローラドライバ** はプラットフォーム固有のホスト
   コントローラハードウェアを利用して、USB上で実際にデータを送受信する
   役割を担っています。このドライバの目的は、USBホストコントローラの違いを
   USBを扱う他のすべてのコードから切り離すことです。Embedded Xinuでは
   USBホストコントローラドライバは :source:`include/usb_hcdi.h` で宣言
   されているインターフェイスを実装する必要があります（ただし、これを
   書いている時点では、実装されているホストUSBコントローラドライバは1つ
   だけで、 :doc:`/arm/rpi/Raspberry-Pi` で使用されている
   :doc:`/arm/rpi/Synopsys-USB-Controller` を制御するものです）。
-  **USBコアドライバ** はツリー構造を含むUSBデバイスモデルの維持と
   USBデバイスドライバを記述するためのフレームワークを提供する役割を
   担っています。ホストコントローラドライバを直接使用するよりもUSB
   デバイスドライバの開発を容易にする多くの便利な機能を提供しています。
   これはプラットフォーム固有のホストコントローラドライバをできるだけ
   分離するための試みであると考えられます。また、デバイスの構成や
   アドレスの設定、ディスクリプタの読み込みなど、すべてのUSBデバイスに
   共通する設定も扱います。Embedded XinuのUSB Core Driverは
   :source:`device/usb/usbcore.c` にあります。
-  **USBデバイスドライバ** は特定のUSBデバイスを制御する役割を担って
   います。USBは動的なバスなので、USBデバイスドライバはUSBコアドライバの
   助けを借りて実行時に実際のUSBデバイスにバインドされます。すべてのUSB
   ソフトウェアスタックで必ず実装されなければならない非常に重要なSUB
   デバイスドライバが **USBハブドライバ** です。このドライバは、USBハブの
   状態の監視とデバイスの着脱をUSBコアドライバに報告する役割を担っています。
   Embedded XinuのUSBハブドライはたとえば。 :source:`device/smsc9512/`
   のように  :source:`device/` にあります。

.. note:: Linuxのスタックのようなより完全（で複雑）なUSBソフトウェア
          スタックでは、USBデバイスではなくUSBインタフェースに関連する
          **USBインタフェースドライバ** もサポートされています。

Embedded XinuのUSBサポートの有効化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Embedded Xinuの特定のビルドにUSBのサポートを含めるには
 ``xinu.conf`` で ``WITH_USB`` を定義し、 ``platformVars`` の
 ``DEVICES`` 変数に  ``usb`` を追加してください。USBハブドライバは
 USBがあらゆるデバイスをサポートするために必要なものなので自動的に
 含まれることに注意してください。

さらに、プラットフォームに固有でこのディレクトリには存在しない
適切なホストコントローラデバイスを書いて、カーネルにコンパイルする
必要があります。たとえば、 :source:`system/platforms/arm-rpi/usb_dwc_hcd.c`
はRaspberry Piハードウェアで使用されるホストコントローラデバイスです。

最後に、サポートしたい実際のUSBデバイスを対応するデバイスディレクトリを ``platformVars`` の ``DEVICES`` 変数に追加し、 ``xinu.conf`` で適切な
スタティックデバイスを定義することにより有効にする必要があります。たとえば、Raspberry Piでは :source:`device/smsc9512` にあるSMSC LAN9512 USB Ethernet
Adapterのドライバを有効にするために ``DEVICES`` に ``smsc9512`` を追加し、
``xinu.conf`` で ``ETH0`` デバイスを定義しています。

組込みシステム用のUSB
~~~~~~~~~~~~~~~~~~~~~~~~

デバッグ機能が重要でない完全な組み込みシステムの場合、不要なヒューマン
フレンドリ機能はUSBコアから省略することができます。詳細については
:source:`device/usb/usbdebug.c` を参照してください。

USB関連のシェルコマンド
~~~~~~~~~~~~~~~~~~~~~~~~~~

**usbinfo** :doc:`シェルコマンド <Shell>` は、USBに接続されたデバイスの
情報を表示します。詳細は :source:`shell/xsh_usbinfo.c` を参照するか、
``usbinfo --help`` を実行してください。

.. _how_to_write_usb_device_driver:

USBデバイスドライバの書き方
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

まず、USBデバイスのドキュメントを入手する必要があります。多くのデバイスは
USBの **クラス仕様** に準拠しているため独自のドキュメントを持っていない
ことに注意してください。クラス仕様に準拠している場合、ドキュメントはクラス
仕様書です。ただし、通常、これらは非常に長くて複雑です。

ドキュメントがない非標準デバイスの場合は、他のオペレーティングシステムの
ソースコードなど、デバイスのプロトコルを理解するために利用可能なあらゆる
手段を使用する必要があります。最後の手段として、バイナリドライバが生成する
USBトラフィックを盗み見ることによりUSBデバイスのソフトウェアインタフェースを
リバースエンジニアリングすることができます。

いずれにせよ、ドライバを書くためには、デバイスとやり取りされるメッセージの
形式と意味、そしてそれらがどのUSBエンドポイントと転送タイプに関連付けられて
いるかを理解する必要があります。

例:

- マウスウスなどのUSBヒューマンインタフェースデバイスはマウス座標などの
  入力データの報告に使用されるINインターラプトエンドポイントが必要であり、
  ある種のメタデータはデフォルトのコントロールエンドポイントから問い
  合わせることができます。
- :doc:`/arm/rpi/SMSC-LAN9512` のようなUSBネットワークデバイスは
  ネットワークパケットを受信するためのバルクINエンドポイントと
  ネットワークパケットを送信するためのバルクOUTエンドポイントを提供します。

コードそのものについては、Embedded XinuではUSBデバイスドライバは
:source:`usb_core_driver.h` で宣言されているUSBコアドライバが提供する
APIを使って実装されます。このAPIによりドライバはドライバ自身の登録、
コアによって検出されるUSBデバイスへのバインド、USBデバイスとの通信が
可能になります。これらについてはソースコードに非常に詳しく記述されて
います。また、USBデバイスドライバの例については
:source:`device/smsc9512/` を参照してください。

Xinuの静的デバイスモデルはUSBの動的デバイスモデルとは互換性がない
ことに注意してください。そのためUSBデバイスドライバで回避策が必要な
場合があります。たとえば、ドライバは一定数以上のUSBデバイスとの
バインドを拒否するかもしれませんし、USBデバイスに実際にバインド
される前にコードが静的デバイスを開こうとするとブロックしたり失敗を
返したりするかもしれません。

USBホストコントローラドライバの書き方
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Embedded Xinuでは、USBホストコントローラドライバは実際にハードウェア
（USBホストコントローラ）と対話し、USB上でデータを送受信する役割を担って
います。残念ながら、USBホストコントローラはUSB仕様では標準化されておらず、
それがこの抽象化レイヤが必要である理由となっています。USBホスト
コントローラにはUHCI、OHCI、EHCIの各仕様に準拠したものもあれば、
:doc:`/arm/rpi/Raspberry-Pi` に使用されている
:doc:`/arm/rpi/Synopsys-USB-Controller` のような非標準のものもあります。

最初のステップは、Xinuが対象となるハードウェアのUSBホストコントローラを
すでにサポートしているか否かを確認することです。もししていればそのコードを
使うことができますが、変更が少し必要でしょう（たとえば、メモリマップド
レジスタの位置など）。そうでない場合は、続きをお読みください。

USBホストコントローラドライバは :source:`include/usb_hcdi.h` で宣言
されているインタフェースを実装する必要があります。

まず、（もしあれば）ホストコントローラのドキュメントを入手する必要が
あります。また、USB2.0仕様の関連部分（主にコントロール、インターラプト、
バルクの各転送について記述されている部分）を読む必要があります。
650ページのほとんどは読む必要が **ありません** 。

次に、``hcd_start()`` にホストコントローラを使用可能な状態にするために
必要なコードを書く必要があります。

次の、そして本質的に最後のステップは ``hcd_submit_xfer_request()`` の
実装ですが、これは非常に難しいです。最初は、ルートハブに送信される
偽のリクエストに焦点を当てるべきです。これにはルートハブのデフォルト
エンドポイントとの間の様々なコントロール転送とルートハブのステータス
変更エンドポイントからのインターラプト転送が含まれます。ルートハブの
リクエストにはソフトウェアですべて処理できるものと、ホストコントローラと
通信する必要があるものがあります。次に、バス上の実際のUSBデバイスとの
間のコントロール転送をサポートする必要があります。最後に、インターラプト
転送とバルク転送をサポートする必要があります。これらは、非同期かつ
割り込み駆動である必要があります。ハブドライバはポートの状態変化を
検出するためにインターラプト転送を使用しますので、インターラプト転送を
実装しないとUSB全体のエヌメレーションをすることができないことに注意
してください。

デバッグメッセージを表示するために ``usb_debug()`` マクロと
``usb_dev_debug()`` マクロを使用することができます。有効にするには
:source:`include/usb_util.h` にあるログ優先順位を変更してください。

さらなる読み物
---------------

- `USB 2.0 Specification <http://www.usb.org/developers/docs/>`__
- `USB 3.1 Specification <http://www.usb.org/developers/docs/>`__
- Embedded Xinu USB 2.0 サブシステム. (:source:`device/usb`)
- Embedded Xinu USB デバイスドライバ. (例: :source:`device/smsc9512/`)
- Embedded Xinu USB ホストコントローラドライバ. (例: :source:`system/platforms/arm-rpi/usb_dwc_hcd.c`)
