シェル
========

**XINUシェル** (**xsh**)は人がオペレーティングシステムと対話する
ための簡単なコマンドラインインターフェイスとして機能するサブ
システムです。 :source:`shell/` に実装されています。

動作の仕組み
----------------

シェルの起動
~~~~~~~~~~~~~~~~

.. note:: このセクションではプログラムでシェルを起動する方法について
          説明します。デフォルトではこれはすでに :source:`system/main.c`
          により実行されています。

XINUシェルのインスタンスは :source:`shell() <shell/shell.c>`
プロシージャを実行する :source:`スレッドを作成する <system/create.c>`
ことで開始できます。このプロシージャは次のように宣言されています。

.. code:: c

  thread shell(int indescrp, int outdescrp, int errdescrp);

シェルは ``indescrp`` で指定されたキャラクタデバイスからコマンドを
読み込んで実行します。実行されたシェルコマンドによって
:source:`stdout <include/stdio.h>` に書き込まれた出力は ``outdescrp``
で指定されたデバイスに、 :source:`stderr <include/stdio.h>` に
書き込まれた出力は ``errdescrp`` で指定されたデバイスに送られます。

:source:`system/main.c` で見られるように、シェルを起動する典型的な
例は次のとおりです。

.. code:: c

    ready(create
              ((void *)shell, INITSTK, INITPRIO, "SHELL0", 3,
                         CONSOLE, CONSOLE, CONSOLE), RESCHED_NO);

ここではすべての入出力に ``CONSOLE`` デバイスを使用していますが、
通常、これは最初のシリアルポート、すなわちUARTをラップする
:doc:`TTYデバイス <TTY-Driver>` としてセットアップされます。

.. code:: c

    open(CONSOLE, SERIAL0);

キーボードやフレームバッファ、または、追加のシリアルポートなどの
入出力デバイスが利用可能な場合は、さらにシェルスレッドを起動する
ことができます。

コマンドの読み込みと実行
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ユーザがシェルでコマンドを入力すると :source:`lexan() <shell/lexan.c>`
関数が入力文字列をトークンに分割します。コマンド名、引数、引用符で
囲まれた文字列、バックグラウンドトークン、 リダイレクトトークンの
すべてが :source:`lexan() <shell/lexan.c>` により認識され、分割
されます。

コマンドがパースされると、シェルはトークンを使用して与えられた
コマンドを適切に実行します。シェルはまずバックグラウンド実行を
指定するアンパサンド ('&') をチェックします。これは最後のトークンと
してしか現れないはずです。シェルはリダイレクトを処理するように
設計されていますが、XINUのファイルシステムは開発中であるため、
現在は処理されません。

次に、コマンドが :source:`shell/shell.c` の冒頭で定義されている
コマンドテーブルから検索されます。コマンドテーブルの各エントリは
``{"command_name", TRUE / FALSE, xsh_function}`` :
すなわち、コマンド名、ビルトイン関数の是非（すなわち、バック
グラウンドで実行可能か）、コマンドを実行する関数からなる
フォーマットで記述されています。

ビルトインコマンドはそのコマンドを実装している関数を呼び出すことで
実行されます。他のすべてのコマンドは新しいプロセスを作成することに
より実行されます。ユーザが入力にバックグラウンド化フラグを含めなかった
場合、シェルはコマンドのプロセスが完了するまで待ってから、さらに
入力を求めます。

コマンド一覧
----------------

XINUのビルドで実際に利用できるシェルコマンドは、プラットフォームや
有効化された機能によって異なりますが、重要なコマンドを以下に
リストアップします。

=============   ===========
コマンド        説明
=============   ===========
**clear**       シェルの出力をクリアします
**exit**        シェルを終了します
**help**        サポートコマンド、または特定のコマンドヘルプを表示します
**kill**        指定のスレッドをkillします
**memstat**     現在のメモリ使用状況を表示し、フリーリストを出力します
**memdump**     メモリ領域をダンプします
**ps**          実行中のプロセス一覧を表示します
**reset**       システムをソフトリセットします
**sleep**       指定した時間だけ実行中のスレッドをsleepさせます
**test**        デフォルトでは何もしませんが、開発者はここに一時的にコードを追加できます
**testsuite**   システムが正しく機能しているかを調べる一連のテストを実行します
**uartstat**    UARTに関する情報を表示します
=============   ===========

コマンドの完全なリストはシェル上で ``help``  コマンドを実行する
ことにより得られます。特定のコマンドのヘルプは `COMMAND --help``
または ``help COMMAND`` で得られます。

コマンドの追加
---------------

シェルはユーザが独自にコマンドを追加できるように拡張性を持たせています。
シェルを実行するコード (:source:`shell/shell.c`) とコマンドパーサ
(:source:`shell/lexan.c`) は新しいコマンドを追加する際、変更する
必要はありません。作業の大部分は実際のコマンドを書くことです。
コマンドを書いたら次の3項目をシステムに追加する必要があります。

-  関数プロトタイプのヘッダーファイル (:source:`include/shell.h`)
   への追加
-  コマンドテーブル (:source:`shell/shell.c`) への追加
-  この関数を含むファイルをビルドするためにmakeファイル
   (:source:`shell/Makerules`) への追加

関数を書く
~~~~~~~~~~~~~~~~~~~~

コマンドは独自のCソースファイルを :source:`shell/` ディレクトリに
作成します。その名前は ``xsh_command.c`` という命名規則に従います。
すべてのコマンドファイルにはコマンドに必要なのヘッダーの他に
``kernel.h`` と ``shell.h`` をインクルードする必要があります。
コマンドの関数名はソースファイルと同じ ``xsh_command`` という
命名規則に従います。コマンドのメソッドシグネチャは次のとおりです。

.. code:: c

  shellcmd xsh_command(int nargs, char *args[])

コマンド内では引数は ``args`` 配列経由でアクセスします。コマンド名が
``arg[0]`` に格納され、それ以降の引数は ``nargs`` まで ``arg[n]``
を介してアクセスできます。引数のエラーチェックはコマンド関数が
行います。引数の数が正しいかをチェックするのは良い慣習です。
コマンド名が ``nargs`` に含まれるので引数のないコマンドは
``nargs == 1`` となることを忘れないでください。必須ではありませんが
コマンド関数は ``arg[1]`` として ``--help`` という引数を指定できる
ようにするべきです。この引数はコマンドの使用法を表示するようにします。
ユーザがシェルで ``help COMMAND`` とタイプすると ``--help`` を
引数として ``COMMAND`` が呼び出されます。

コマンド関数内のその他のコードはコマンドが何を行うかによります。
コマンドが完了したら ``OK`` を返す必要があります。

コマンドテーブルへの追加
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

コマンド関数を書いたら、そのコマンドをコマンドテーブルに追加して
シェルがそのコマンドを認識できるようにする必要があります。
コマンドテーブルは ``shell/shell.c`` で定義されている  ``centry``
（コマンドエントリ）構造体の配列です。コマンドテーブルの各エントリは
コマンド名、ビルトインコマンドか（コマンドがバックグラウンドで実行
できるか）、コマンドを実行する関数からなる次のフォーマットに従います:
``{"command_name", TRUE / FALSE, xsh_function},``

ヘッダーとmakfileへの追加
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

プロセスを完了するために、関数プロトタイプをシェルのヘッダーファイル
``include/shell.h`` に追加します。

.. code:: c

    shellcmd xsh_command(int, char *[]);

最後に、コマンド関数のソースファイルを makefile (``shell/Makerules``)
の ``C_FILES`` グループに追加し、コマンドがXINUのブートイメージに
コンパイルされるようにします。

例
~~~~~~~

echoコマンドをシステムに追加する簡単な実装を行います。

関数を書く
^^^^^^^^^^^^^^^^^^

まず、ソースファイル ``shell/xsh_echo.c`` を作成します。すべての
コマンドは同じ引数（シェルから渡さる）を取るので次のようになります。

.. code:: c

    #include <kernel.h>
    #include <stdio.h>
    #include <string.h>

    /**
     * このシェルコマンドは入力されたテキストを標準出力にエコーします。
     * @param stdin 入力デバイスのディスクリプタ
     * @param stdout 出力デバイスのディスクリプタ
     * @param stderr エラー出力デバイスのディスクリプタ
     * @param args 引数の配列
     * @return 成功の場合はOK、文法エラーの場合はSYSERR
     */
    shellcmd xsh_echo(int nargs, char *args[])
    {
        int i;  /* counter for looping through arguments */

        /* Output help, if '--help' argument was supplied */
        if (nargs == 2 && strcmp(args[1], "--help") == 0)
        {
            fprintf(stdout, "Usage: clear\n");
            fprintf(stdout, "Clears the terminal.\n");
            fprintf(stdout, "\t--help\t display this help and exit\n");
            return SYSERR;
        }

        /* loop through the arguments printing each as it is displayed */
        for ( i = 1; i < nargs; i++ )
        {
            fprintf(stdout, "%s ", args[i]);
        }

        /* Just so the next prompt doesn't run on to this line */
        fprintf(stdout, "\n");

        /* there were no errors so, return OK */
        return OK;
    }

関数をコマンドテーブルに追加する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

:source:`shell/` ディレクトリに移動し :source:`shell/shell.c`
の先頭にあるコマンドテーブルを変更します。echoコマンドを追加する
のでシェルでのユーザーの入力は "``echo``" にするのがもっとも
ふさわしいと思われます。この関数はビルトイン関数ではなく
(FALSE)、実装している関数は xsh\_echo です。エントリは次のように
なりあす。

.. code:: c

    { "echo", FALSE, xsh_echo }

関数プロトタイプをインクルードファイルに追加する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

次に、関数のプロトタイプをシェルのインクルードファイル
:source:`include/shell.h` に追加する必要があります。これには
次の一行を追加するだけです。

.. code:: c

    shellcmd xsh_echo(int, char *[]);

Makefileにファイルを追加する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

最後に（そしてもっとも重要ですが）関数をMakefileに追加してコンパイルが
ビルドするようにします。これには ``shell/Makerules`` で
"``C_FILES =``\ " で始まる行を探して、その最後に xsh\_echo.c を
追加します。

コンパイルして実行すると、XINUシステムで使用可能な ``echo``
コマンドの実装があるはずです。
